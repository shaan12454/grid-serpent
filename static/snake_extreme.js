(function(){
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const scoreEl = document.getElementById('score');
  const lengthEl = document.getElementById('length');
  const timeEl = document.getElementById('time');
  const nameEl = document.getElementById('playerName');
  const modeSel = document.getElementById('modeSelect');
  let W = window.innerWidth * 0.9; let H = Math.min(window.innerHeight * 0.7, 900);
  let cellSize = 20; let cols = Math.floor(W / cellSize); let rows = Math.floor(H / cellSize);
  canvas.width = cols * cellSize; canvas.height = rows * cellSize;
  let snake = []; let dir = {x:1,y:0}; let nextDir = null; let food = []; let obstacles = []; let score = 0; let isRunning = false; let interval = null; let tickMs = 120; let elapsed = 0; let startTime = 0; let mode = 'classic';
  const FRUITS = [ {type:'apple',points:10,prob:0.6, grow:1}, {type:'gold',points:30,prob:0.15, grow:2}, {type:'bomb',points:-20,prob:0.05, grow:0, effect:'shrink'}, {type:'speed',points:0,prob:0.1, grow:0, effect:'speedup',duration:8000}, {type:'slow',points:0,prob:0.1, grow:0, effect:'slow',duration:8000} ];
  function chooseFruit(){ let r=Math.random(); let acc=0; for(let f of FRUITS){ acc+=f.prob; if(r<=acc) return {...f}; } return {...FRUITS[0]}; }
  function resetGrid(){ W = window.innerWidth * 0.9; H = Math.min(window.innerHeight * 0.7, 900); cols = Math.floor(W / cellSize); rows = Math.floor(H / cellSize); canvas.width = cols * cellSize; canvas.height = rows * cellSize; }
  function newGame(){ resetGrid(); snake=[{x:Math.floor(cols/2), y:Math.floor(rows/2)}]; dir={x:1,y:0}; nextDir=null; food=[]; obstacles=[]; score=0; elapsed=0; startTime=Date.now(); mode=modeSel.value; tickMs = mode==='speedrun'?80:120; if(mode==='arena' || mode==='extreme'){ let wallCount = mode==='arena'? Math.floor(cols*rows*0.02) : Math.floor(cols*rows*0.06); for(let i=0;i<wallCount;i++){ obstacles.push({x:Math.floor(1+Math.random()*(cols-2)), y:Math.floor(1+Math.random()*(rows-2))}); } } for(let i=0;i<Math.max(3, Math.floor(cols*rows*0.002)); i++){ spawnFood(); } isRunning=true; clearInterval(interval); interval=setInterval(tick, tickMs); updateHUD(); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function spawnFood(){ let tries=0; while(tries<200){ let fx=randInt(1,cols-2), fy=randInt(1,rows-2); if(cellOccupied(fx,fy)){ tries++; continue;} let f=chooseFruit(); f.x=fx; f.y=fy; f.spawned=Date.now(); food.push(f); break; } }
  function cellOccupied(x,y){ if(snake.some(s=>s.x===x && s.y===y)) return true; if(obstacles.some(o=>o.x===x && o.y===y)) return true; if(food.some(f=>f.x===x && f.y===y)) return true; return false; }
  function tick(){ if(nextDir){ dir=nextDir; nextDir=null;} let head={x:snake[0].x+dir.x, y:snake[0].y+dir.y}; if(mode==='classic' || mode==='speedrun'){ if(head.x<0) head.x=cols-1; if(head.x>=cols) head.x=0; if(head.y<0) head.y=rows-1; if(head.y>=rows) head.y=0; } if(mode!=='classic'){ if(head.x<0||head.x>=cols||head.y<0||head.y>=rows){ return gameOver(); } } if(obstacles.some(o=>o.x===head.x && o.y===head.y)){ return gameOver(); } if(snake.some(s=>s.x===head.x && s.y===head.y)){ return gameOver(); } snake.unshift(head); let ate=false; for(let i=0;i<food.length;i++){ let f=food[i]; if(f.x===head.x && f.y===head.y){ ate=true; applyFruitEffect(f); food.splice(i,1); if(Math.random()<0.8) spawnFood(); break; } } if(!ate) snake.pop(); updateHUD(); render(); elapsed=Math.floor((Date.now()-startTime)/1000); timeEl.textContent=elapsed; }
  function applyFruitEffect(f){ score+=f.points; if(f.grow>0){ for(let k=0;k<f.grow;k++) snake.push({...snake[snake.length-1]}); } if(f.effect==='shrink'){ let keep=Math.max(1, Math.floor(snake.length/2)); snake = snake.slice(0,keep); } if(f.effect==='speedup'){ clearInterval(interval); tickMs=Math.max(40, tickMs-30); interval=setInterval(tick, tickMs); setTimeout(()=>{ clearInterval(interval); tickMs=Math.min(140, tickMs+30); interval=setInterval(tick, tickMs); }, f.duration||5000); } if(f.effect==='slow'){ clearInterval(interval); tickMs=tickMs+40; interval=setInterval(tick, tickMs); setTimeout(()=>{ clearInterval(interval); tickMs=Math.max(40, tickMs-40); interval=setInterval(tick, tickMs); }, f.duration||5000); } }
  function gameOver(){ isRunning=false; clearInterval(interval); render(); setTimeout(()=>{ let p = prompt('Game Over! Your score: '+score+'. Enter name to submit (or Cancel):', nameEl.value||'Player'); if(p!==null){ submitScore(p); nameEl.value=p; } },50); }
  function submitScore(name){ fetch('/submit_score',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({score:score, name:name, mode:mode}) }).then(r=>r.json()).then(()=>{ window.location.href='/scores'; }).catch(e=>{ console.error(e); }); }
  function updateHUD(){ scoreEl.textContent=score; lengthEl.textContent=snake.length; }
  function render(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#021022'; ctx.fillRect(0,0,canvas.width,canvas.height); for(let o of obstacles){ drawCell(o.x,o.y,'#6b7280'); } for(let f of food){ let color='#34d399'; if(f.type==='gold') color='#f59e0b'; if(f.type==='bomb') color='#ef4444'; if(f.type==='speed') color='#60a5fa'; if(f.type==='slow') color='#a78bfa'; drawCell(f.x,f.y,color); } for(let i=0;i<snake.length;i++){ let s=snake[i]; drawCell(s.x,s.y, i===0? '#10b981' : '#059669'); } ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(6,6,220,36); ctx.fillStyle='#ffffff'; ctx.font='16px sans-serif'; ctx.fillText('Score: '+score,12,28); }
  function drawCell(x,y,color){ ctx.fillStyle=color; ctx.fillRect(x*cellSize+1,y*cellSize+1,cellSize-2,cellSize-2); }
  document.addEventListener('keydown', function(e){ if(!isRunning && e.key===' '){ newGame(); return; } const map={'ArrowUp':[0,-1],'ArrowDown':[0,1],'ArrowLeft':[-1,0],'ArrowRight':[1,0],'w':[0,-1],'s':[0,1],'a':[-1,0],'d':[1,0]}; let k=e.key; if(k in map){ let nd={x:map[k][0], y:map[k][1]}; if(snake.length>1 && nd.x===-dir.x && nd.y===-dir.y) return; nextDir=nd; } });
  let touchStart=null; canvas.addEventListener('touchstart', function(e){ touchStart=e.touches[0]; }, {passive:true}); canvas.addEventListener('touchmove', function(e){ if(!touchStart) return; let t=e.touches[0]; let dx=t.clientX-touchStart.clientX; let dy=t.clientY-touchStart.clientY; if(Math.abs(dx)>30 || Math.abs(dy)>30){ if(Math.abs(dx)>Math.abs(dy)) nextDir={x: dx>0?1:-1, y:0}; else nextDir={x:0, y: dy>0?1:-1}; touchStart=null; } }, {passive:true});
  startBtn.addEventListener('click', ()=>{ newGame(); }); pauseBtn.addEventListener('click', ()=>{ if(isRunning){ clearInterval(interval); isRunning=false; pauseBtn.textContent='Resume'; } else { interval=setInterval(tick, tickMs); isRunning=true; pauseBtn.textContent='Pause'; } });
  setInterval(()=>{ if(isRunning && Math.random()<0.4) spawnFood(); }, 1500);
  window.addEventListener('resize', ()=>{ resetGrid(); if(isRunning) render(); }); render();
})();
